import {
  s as t,
  C as e,
  b as n,
  N as o,
  a as s,
  c as r,
  d as i,
  e as a,
  g as c,
  r as u,
  f as d,
  P as l,
  h as f,
  j as p,
  k as m,
  l as h,
  t as g,
  n as v,
  o as y,
  p as w,
  q as S,
  v as x,
  w as E,
  x as N,
  y as I,
  z as b,
  A as T,
  B as C,
  D as R,
  E as D,
  R as _,
  F as M,
  G as O,
  H as L,
  I as k,
  J as A,
  K as P,
  L as z,
  M as V,
  O as H,
  Q as F,
  S as $,
  T as B,
  U as G,
  V as U,
  W as Y,
  Y as j,
  Z as X,
  _ as W,
  $ as q,
} from "./datadog-z19OuTVm.js";
import "./index-BVS4T5_D.js";
import "./Main-Baot3sP1.js";
import "./SavedPromptsService-Ca57zNuQ.js";
import "./index-D6M7XaCF.js";
const J = 2,
  K = 3,
  Z = 4,
  Q = 6,
  tt = 7,
  et = 8,
  nt = 9,
  ot = 0,
  st = 1,
  rt = 2,
  it = 3,
  at = 4,
  ct = 11,
  ut = 0,
  dt = 1,
  lt = 2,
  ft = 3,
  pt = 4,
  mt = 5,
  ht = 6,
  gt = 7,
  vt = 8,
  yt = 5,
  wt = 6,
  St = 0,
  xt = 1;
function Et(n, o) {
  const s = n.tagName,
    r = n.value;
  if (t(n, o)) {
    const t = n.type;
    if ("INPUT" === s && ("button" === t || "submit" === t || "reset" === t))
      return r;
    if (!r || "OPTION" === s) return;
    return e;
  }
  return "OPTION" === s || "SELECT" === s
    ? n.value
    : "INPUT" === s || "TEXTAREA" === s
      ? r
      : void 0;
}
const Nt = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm,
  It = /^[A-Za-z]+:|^\/\//,
  bt = /^["']?data:.*,/i;
function Tt(t, e) {
  return t.replace(Nt, (t, o, s, r, i, a) => {
    const c = s || i || a;
    if (!e || !c || It.test(c) || bt.test(c)) return t;
    const u = o || r || "";
    return `url(${u}${(function (t, e) {
      try {
        return n(t, e).href;
      } catch (o) {
        return t;
      }
    })(c, e)}${u})`;
  });
}
const Ct = /[^a-z1-6-_]/;
function Rt(t) {
  return t.tagName.toLowerCase();
}
function Dt(t, e) {
  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${t}' height='${e}' style='background-color:silver'%3E%3C/svg%3E`;
}
function _t(t) {
  if (void 0 !== t && 0 !== t.length)
    return t.map((t) => {
      const e = t.cssRules || t.rules;
      return {
        cssRules: Array.from(e, (t) => t.cssText),
        disabled: t.disabled || void 0,
        media: t.media.length > 0 ? Array.from(t.media) : void 0,
      };
    });
}
function Mt(t, n, a, c) {
  if (n === o.HIDDEN) return null;
  const u = t.getAttribute(a),
    d = t.tagName;
  if (s(d, a, u, n, c)) {
    if ("IMG" === d) {
      const e = t;
      if (e.naturalWidth > 0) return Dt(e.naturalWidth, e.naturalHeight);
      const { width: n, height: o } = t.getBoundingClientRect();
      return n > 0 || o > 0 ? Dt(n, o) : r;
    }
    return "SOURCE" === d ? r : e;
  }
  return u ? i(u, 1e6) : u;
}
function Ot(e, n, s) {
  if (n === o.HIDDEN) return {};
  const r = {},
    i = Rt(e);
  for (let t = 0; t < e.attributes.length; t += 1) {
    const o = e.attributes.item(t).name,
      i = Mt(e, n, o, s.scope.configuration);
    null !== i && (r[o] = i);
  }
  if (
    e.value &&
    ("textarea" === i || "select" === i || "option" === i || "input" === i)
  ) {
    const t = Et(e, n);
    void 0 !== t && (r.value = t);
  }
  if ("option" === i) {
    const o = e;
    o.selected && !t(o, n) ? (r.selected = "") : delete r.selected;
  }
  const a = e;
  return (
    "input" !== i ||
      ("radio" !== a.type && "checkbox" !== a.type) ||
      (a.checked && !t(a, n) ? (r.checked = "") : delete r.checked),
    r
  );
}
function Lt(t, e, n) {
  if (e === o.HIDDEN) return {};
  const s = {},
    r = t.ownerDocument,
    i = Rt(t);
  if ("link" === i) {
    const e = Array.from(r.styleSheets).find((e) => e.href === t.href),
      o = kt(e);
    o && e && (n.addMetric("cssText", o.length), (s._cssText = o));
  }
  if ("style" === i && t.sheet) {
    const e = kt(t.sheet);
    e && (n.addMetric("cssText", e.length), (s._cssText = e));
  }
  if ("audio" === i || "video" === i) {
    const e = t;
    s.rr_mediaState = e.paused ? "paused" : "played";
  }
  let a, c;
  switch (n.kind) {
    case 0:
      ((a = Math.round(t.scrollTop)),
        (c = Math.round(t.scrollLeft)),
        (a || c) &&
          n.scope.elementsScrollPositions.set(t, {
            scrollTop: a,
            scrollLeft: c,
          }));
      break;
    case 1:
      n.scope.elementsScrollPositions.has(t) &&
        ({ scrollTop: a, scrollLeft: c } =
          n.scope.elementsScrollPositions.get(t));
  }
  return (c && (s.rr_scrollLeft = c), a && (s.rr_scrollTop = a), s);
}
function kt(t) {
  if (!t) return null;
  let e;
  try {
    e = t.rules || t.cssRules;
  } catch (n) {}
  if (!e) return null;
  return Tt(Array.from(e, a() ? At : Pt).join(""), t.href);
}
function At(t) {
  if (
    (function (t) {
      return "selectorText" in t;
    })(t) &&
    t.selectorText.includes(":")
  ) {
    const e = /(\[[\w-]+[^\\])(:[^\]]+\])/g;
    return t.cssText.replace(e, "$1\\$2");
  }
  return Pt(t);
}
function Pt(t) {
  return (
    ((function (t) {
      return "styleSheet" in t;
    })(t) &&
      kt(t.styleSheet)) ||
    t.cssText
  );
}
function zt(t, e, n) {
  switch (t.nodeType) {
    case t.DOCUMENT_NODE:
      return (function (t, e, n) {
        return {
          type: ot,
          id: n.assignId(t),
          childNodes: Vt(t, e, n),
          adoptedStyleSheets: _t(t.adoptedStyleSheets),
        };
      })(t, e, n);
    case t.DOCUMENT_FRAGMENT_NODE:
      return (function (t, e, n) {
        const o = m(t);
        o && n.scope.shadowRootsController.addShadowRoot(t, n.scope);
        return {
          type: ct,
          id: n.assignId(t),
          childNodes: Vt(t, e, n),
          isShadowRoot: o,
          adoptedStyleSheets: o ? _t(t.adoptedStyleSheets) : void 0,
        };
      })(t, e, n);
    case t.DOCUMENT_TYPE_NODE:
      return (function (t, e) {
        return {
          type: st,
          id: e.assignId(t),
          name: t.name,
          publicId: t.publicId,
          systemId: t.systemId,
        };
      })(t, n);
    case t.ELEMENT_NODE:
      return (function (t, e, n) {
        const s = (function (t) {
            const e = t.toLowerCase().trim();
            return Ct.test(e) ? "div" : e;
          })(t.tagName),
          r =
            ((a = t), "svg" === a.tagName || a instanceof SVGElement || void 0),
          i = u(d(t), e);
        var a;
        if (i === o.HIDDEN) {
          const { width: e, height: o } = t.getBoundingClientRect();
          return {
            type: rt,
            id: n.assignId(t),
            tagName: s,
            attributes: { rr_width: `${e}px`, rr_height: `${o}px`, [f]: l },
            childNodes: [],
            isSVG: r,
          };
        }
        if (i === o.IGNORE) return null;
        const c = n.assignId(t),
          m = (function (t, e, n) {
            return { ...Ot(t, e, n), ...Lt(t, e, n) };
          })(t, i, n);
        let h = [];
        p(t) && "style" !== s && (h = Vt(t, i, n));
        return {
          type: rt,
          id: c,
          tagName: s,
          attributes: m,
          childNodes: h,
          isSVG: r,
        };
      })(t, e, n);
    case t.TEXT_NODE:
      return (function (t, e, n) {
        const o = c(t, e);
        if (void 0 === o) return null;
        return { type: it, id: n.assignId(t), textContent: o };
      })(t, e, n);
    case t.CDATA_SECTION_NODE:
      return (function (t, e) {
        return { type: at, id: e.assignId(t), textContent: "" };
      })(t, n);
    default:
      return null;
  }
}
function Vt(t, e, n) {
  const o = [];
  return (
    h(t, (t) => {
      const s = zt(t, e, n);
      s && o.push(s);
    }),
    o
  );
}
function Ht(t, e) {
  return zt(t, e.scope.configuration.defaultPrivacyLevel, e);
}
function Ft(t, e, n) {
  ((t[e].count += 1), (t[e].max = Math.max(t[e].max, n)), (t[e].sum += n));
}
function $t(t, e, n, o, s) {
  const r = [],
    i = {
      cssText: { count: 0, max: 0, sum: 0 },
      serializationDuration: { count: 0, max: 0, sum: 0 },
    },
    a = {
      add(t) {
        r.push(t);
      },
      addMetric(t, e) {
        Ft(i, t, e);
      },
      assignId(t) {
        const e = o.nodeIds.assign(t);
        return (a.serializedNodeIds && a.serializedNodeIds.add(e), e);
      },
      kind: t,
      scope: o,
    },
    c = g();
  (s(a), Ft(i, "serializationDuration", v(c, g())));
  for (const u of r) e(u);
  n(i);
}
const Bt = (t, e) => {
    const n = window.visualViewport,
      o = {
        layoutViewportX: t,
        layoutViewportY: e,
        visualViewportX: t,
        visualViewportY: e,
      };
    return n
      ? (!(function (t) {
          return (
            Math.abs(t.pageTop - t.offsetTop - window.scrollY) > 25 ||
            Math.abs(t.pageLeft - t.offsetLeft - window.scrollX) > 25
          );
        })(n)
          ? ((o.visualViewportX = Math.round(t - n.offsetLeft)),
            (o.visualViewportY = Math.round(e - n.offsetTop)))
          : ((o.layoutViewportX = Math.round(t + n.offsetLeft)),
            (o.layoutViewportY = Math.round(e + n.offsetTop))),
        o)
      : o;
  },
  Gt = (t) => ({
    scale: t.scale,
    offsetLeft: t.offsetLeft,
    offsetTop: t.offsetTop,
    pageLeft: t.pageLeft,
    pageTop: t.pageTop,
    height: t.height,
    width: t.width,
  });
function Ut(t, e, n, o, s) {
  $t(e, n, o, s, (e) => {
    const { width: n, height: o } = y();
    (e.add({
      data: { height: o, href: window.location.href, width: n },
      type: Z,
      timestamp: t,
    }),
      e.add({
        data: { has_focus: document.hasFocus() },
        type: Q,
        timestamp: t,
      }),
      e.add({
        data: { node: Ht(document, e), initialOffset: { left: S(), top: w() } },
        type: J,
        timestamp: t,
      }),
      window.visualViewport &&
        e.add({ data: Gt(window.visualViewport), type: et, timestamp: t }));
  });
}
function Yt(t) {
  return Boolean(t.changedTouches);
}
function jt(t) {
  return !0 === t.composed && E(t.target) ? t.composedPath()[0] : t.target;
}
function Xt(t, e) {
  return { data: { source: t, ...e }, type: K, timestamp: g() };
}
function Wt(t, e) {
  const { throttled: n, cancel: o } = N(
      (n) => {
        const o = jt(n),
          s = e.nodeIds.get(o);
        if (void 0 === s) return;
        const r = qt(n);
        if (!r) return;
        const i = { id: s, timeOffset: 0, x: r.x, y: r.y };
        t(Xt(Yt(n) ? ht : dt, { positions: [i] }));
      },
      50,
      { trailing: !1 },
    ),
    { stop: s } = I(e.configuration, document, ["mousemove", "touchmove"], n, {
      capture: !0,
      passive: !0,
    });
  return {
    stop: () => {
      (s(), o());
    },
  };
}
function qt(t) {
  let { clientX: e, clientY: n } = Yt(t) ? t.changedTouches[0] : t;
  if (window.visualViewport) {
    const { visualViewportX: t, visualViewportY: o } = Bt(e, n);
    ((e = t), (n = o));
  }
  if (Number.isFinite(e) && Number.isFinite(n)) return { x: e, y: n };
}
const Jt = {
  pointerup: 0,
  mousedown: 1,
  click: 2,
  contextmenu: 3,
  dblclick: 4,
  focus: yt,
  blur: wt,
  touchstart: 7,
  touchend: 9,
};
function Kt(t, e) {
  return I(
    e.configuration,
    document,
    Object.keys(Jt),
    (n) => {
      const s = jt(n),
        r = e.nodeIds.get(s);
      if (
        void 0 === r ||
        b(s, e.configuration.defaultPrivacyLevel) === o.HIDDEN
      )
        return;
      const i = Jt[n.type];
      let a;
      if (i !== wt && i !== yt) {
        const t = qt(n);
        if (!t) return;
        a = { id: r, type: i, x: t.x, y: t.y };
      } else a = { id: r, type: i };
      t({ id: e.eventIds.getIdForEvent(n), ...Xt(lt, a) });
    },
    { capture: !0, passive: !0 },
  );
}
function Zt(t, e, n) {
  const { throttled: s, cancel: r } = N((t) => {
      const s = jt(t);
      if (!s) return;
      const r = n.nodeIds.get(s);
      if (
        void 0 === r ||
        b(s, n.configuration.defaultPrivacyLevel) === o.HIDDEN
      )
        return;
      const i =
        s === document
          ? { scrollTop: w(), scrollLeft: S() }
          : {
              scrollTop: Math.round(s.scrollTop),
              scrollLeft: Math.round(s.scrollLeft),
            };
      (n.elementsScrollPositions.set(s, i),
        e(Xt(ft, { id: r, x: i.scrollLeft, y: i.scrollTop })));
    }, 100),
    { stop: i } = T(n.configuration, t, "scroll", s, {
      capture: !0,
      passive: !0,
    });
  return {
    stop: () => {
      (i(), r());
    },
  };
}
function Qt(t, e) {
  const n = C(e.configuration).subscribe((e) => {
    t(Xt(pt, e));
  });
  return {
    stop: () => {
      n.unsubscribe();
    },
  };
}
function te(t, e) {
  const n = window.visualViewport;
  if (!n) return { stop: R };
  const { throttled: o, cancel: s } = N(
      () => {
        t({ data: Gt(n), type: et, timestamp: g() });
      },
      200,
      { trailing: !1 },
    ),
    { stop: r } = I(e.configuration, n, ["resize", "scroll"], o, {
      capture: !0,
      passive: !0,
    });
  return {
    stop: () => {
      (r(), s());
    },
  };
}
function ee(t, e) {
  return I(
    e.configuration,
    document,
    ["play", "pause"],
    (n) => {
      const s = jt(n);
      if (!s) return;
      const r = e.nodeIds.get(s);
      void 0 !== r &&
        b(s, e.configuration.defaultPrivacyLevel) !== o.HIDDEN &&
        t(Xt(gt, { id: r, type: "play" === n.type ? St : xt }));
    },
    { capture: !0, passive: !0 },
  );
}
function ne(t, e) {
  function n(t, n) {
    if (!t || !t.ownerNode) return;
    const o = e.nodeIds.get(t.ownerNode);
    void 0 !== o && n(o);
  }
  const o = [
    D(
      CSSStyleSheet.prototype,
      "insertRule",
      ({ target: e, parameters: [o, s] }) => {
        n(e, (e) => t(Xt(vt, { id: e, adds: [{ rule: o, index: s }] })));
      },
    ),
    D(
      CSSStyleSheet.prototype,
      "deleteRule",
      ({ target: e, parameters: [o] }) => {
        n(e, (e) => t(Xt(vt, { id: e, removes: [{ index: o }] })));
      },
    ),
  ];
  function s(e) {
    o.push(
      D(e.prototype, "insertRule", ({ target: e, parameters: [o, s] }) => {
        n(e.parentStyleSheet, (n) => {
          const r = oe(e);
          r &&
            (r.push(s || 0),
            t(Xt(vt, { id: n, adds: [{ rule: o, index: r }] })));
        });
      }),
      D(e.prototype, "deleteRule", ({ target: e, parameters: [o] }) => {
        n(e.parentStyleSheet, (n) => {
          const s = oe(e);
          s && (s.push(o), t(Xt(vt, { id: n, removes: [{ index: s }] })));
        });
      }),
    );
  }
  return (
    "undefined" != typeof CSSGroupingRule
      ? s(CSSGroupingRule)
      : (s(CSSMediaRule), s(CSSSupportsRule)),
    {
      stop: () => {
        o.forEach((t) => t.stop());
      },
    }
  );
}
function oe(t) {
  const e = [];
  let n = t;
  for (; n.parentRule; ) {
    const t = Array.from(n.parentRule.cssRules).indexOf(n);
    (e.unshift(t), (n = n.parentRule));
  }
  if (!n.parentStyleSheet) return;
  const o = Array.from(n.parentStyleSheet.cssRules).indexOf(n);
  return (e.unshift(o), e);
}
function se(t, e) {
  return I(e.configuration, window, ["focus", "blur"], () => {
    t({ data: { has_focus: document.hasFocus() }, type: Q, timestamp: g() });
  });
}
function re(t, e, n) {
  const o = t.subscribe(12, (t) => {
    var o, s;
    t.rawRumEvent.type === _.ACTION &&
      t.rawRumEvent.action.type === M.CLICK &&
      (null ===
        (s =
          null === (o = t.rawRumEvent.action.frustration) || void 0 === o
            ? void 0
            : o.type) || void 0 === s
        ? void 0
        : s.length) &&
      "events" in t.domainContext &&
      t.domainContext.events &&
      t.domainContext.events.length &&
      e({
        timestamp: t.rawRumEvent.date,
        type: nt,
        data: {
          frustrationTypes: t.rawRumEvent.action.frustration.type,
          recordIds: t.domainContext.events.map((t) =>
            n.eventIds.getIdForEvent(t),
          ),
        },
      });
  });
  return {
    stop: () => {
      o.unsubscribe();
    },
  };
}
function ie(t, e, n) {
  const o = t.subscribe(5, () => {
    (n(), e({ timestamp: g(), type: tt }));
  });
  return {
    stop: () => {
      o.unsubscribe();
    },
  };
}
function ae(e, n, s) {
  const r = s.configuration.defaultPrivacyLevel,
    i = new WeakMap(),
    a = e !== document,
    { stop: c } = I(
      s.configuration,
      e,
      a ? ["change"] : ["input", "change"],
      (t) => {
        const e = jt(t);
        (e instanceof HTMLInputElement ||
          e instanceof HTMLTextAreaElement ||
          e instanceof HTMLSelectElement) &&
          d(e);
      },
      { capture: !0, passive: !0 },
    );
  let u;
  if (a) u = R;
  else {
    const t = [
      O(HTMLInputElement.prototype, "value", d),
      O(HTMLInputElement.prototype, "checked", d),
      O(HTMLSelectElement.prototype, "value", d),
      O(HTMLTextAreaElement.prototype, "value", d),
      O(HTMLSelectElement.prototype, "selectedIndex", d),
    ];
    u = () => {
      t.forEach((t) => t.stop());
    };
  }
  return {
    stop: () => {
      (u(), c());
    },
  };
  function d(e) {
    const n = b(e, r);
    if (n === o.HIDDEN) return;
    const s = e.type;
    let i;
    if ("radio" === s || "checkbox" === s) {
      if (t(e, n)) return;
      i = { isChecked: e.checked };
    } else {
      const t = Et(e, n);
      if (void 0 === t) return;
      i = { text: t };
    }
    l(e, i);
    const a = e.name;
    "radio" === s &&
      a &&
      e.checked &&
      document
        .querySelectorAll(`input[type="radio"][name="${CSS.escape(a)}"]`)
        .forEach((t) => {
          t !== e && l(t, { isChecked: !1 });
        });
  }
  function l(t, e) {
    const o = s.nodeIds.get(t);
    if (void 0 === o) return;
    const r = i.get(t);
    (r && r.text === e.text && r.isChecked === e.isChecked) ||
      (i.set(t, e), n(Xt(mt, { id: o, ...e })));
  }
}
function ce(t, e, n, s) {
  const r = k();
  if (!r) return { stop: R, flush: R };
  const i = (function (t) {
      let e = R,
        n = [];
      function o() {
        (e(), t(n), (n = []));
      }
      const { throttled: s, cancel: r } = N(o, 16, { leading: !1 });
      return {
        addMutations: (t) => {
          (0 === n.length && (e = L(s, { timeout: 100 })), n.push(...t));
        },
        flush: o,
        stop: () => {
          (e(), r());
        },
      };
    })((t) => {
      $t(2, e, n, s, (e) =>
        (function (t, e) {
          const n = new Map();
          t.filter((t) => "childList" === t.type).forEach((t) => {
            t.removedNodes.forEach((t) => {
              ue(t, e.scope.shadowRootsController.removeShadowRoot);
            });
          });
          const s = t.filter(
              (t) =>
                t.target.isConnected &&
                e.scope.nodeIds.areAssignedForNodeAndAncestors(t.target) &&
                b(t.target, e.scope.configuration.defaultPrivacyLevel, n) !==
                  o.HIDDEN,
            ),
            {
              adds: r,
              removes: i,
              hasBeenSerialized: a,
            } = (function (t, e, n) {
              const s = new Set(),
                r = new Map();
              for (const o of t)
                (o.addedNodes.forEach((t) => {
                  s.add(t);
                }),
                  o.removedNodes.forEach((t) => {
                    (s.has(t) || r.set(t, o.target), s.delete(t));
                  }));
              const i = Array.from(s);
              ((a = i),
                a.sort((t, e) => {
                  const n = t.compareDocumentPosition(e);
                  return n & Node.DOCUMENT_POSITION_CONTAINED_BY
                    ? -1
                    : n & Node.DOCUMENT_POSITION_CONTAINS ||
                        n & Node.DOCUMENT_POSITION_FOLLOWING
                      ? 1
                      : n & Node.DOCUMENT_POSITION_PRECEDING
                        ? -1
                        : 0;
                }),
                (n.serializedNodeIds = new Set()));
              var a;
              const c = [];
              for (const f of i) {
                if (d(f)) continue;
                const t = b(
                  f.parentNode,
                  n.scope.configuration.defaultPrivacyLevel,
                  e,
                );
                if (t === o.HIDDEN || t === o.IGNORE) continue;
                const s = zt(f, t, n);
                if (!s) continue;
                const r = x(f);
                c.push({
                  nextId: l(f),
                  parentId: n.scope.nodeIds.get(r),
                  node: s,
                });
              }
              const u = [];
              return (
                r.forEach((t, e) => {
                  const o = n.scope.nodeIds.get(t),
                    s = n.scope.nodeIds.get(e);
                  void 0 !== o &&
                    void 0 !== s &&
                    u.push({ parentId: o, id: s });
                }),
                { adds: c, removes: u, hasBeenSerialized: d }
              );
              function d(t) {
                var e;
                const o = n.scope.nodeIds.get(t);
                return (
                  void 0 !== o &&
                  (null === (e = n.serializedNodeIds) || void 0 === e
                    ? void 0
                    : e.has(o))
                );
              }
              function l(t) {
                let e = t.nextSibling;
                for (; e; ) {
                  const t = n.scope.nodeIds.get(e);
                  if (void 0 !== t) return t;
                  e = e.nextSibling;
                }
                return null;
              }
            })(
              s.filter((t) => "childList" === t.type),
              n,
              e,
            ),
            u = (function (t, e, n) {
              var s;
              const r = [],
                i = new Set(),
                a = t.filter((t) => !i.has(t.target) && (i.add(t.target), !0));
              for (const u of a) {
                if (u.target.textContent === u.oldValue) continue;
                const t = n.scope.nodeIds.get(u.target);
                if (void 0 === t) continue;
                const i = b(
                  x(u.target),
                  n.scope.configuration.defaultPrivacyLevel,
                  e,
                );
                i !== o.HIDDEN &&
                  i !== o.IGNORE &&
                  r.push({
                    id: t,
                    value:
                      null !== (s = c(u.target, i)) && void 0 !== s ? s : null,
                  });
              }
              return r;
            })(
              s.filter((t) => "characterData" === t.type && !a(t.target)),
              n,
              e,
            ),
            d = (function (t, e, n) {
              const o = [],
                s = new Map(),
                r = t.filter((t) => {
                  const e = s.get(t.target);
                  return (
                    (!e || !e.has(t.attributeName)) &&
                    (e
                      ? e.add(t.attributeName)
                      : s.set(t.target, new Set([t.attributeName])),
                    !0)
                  );
                }),
                i = new Map();
              for (const a of r) {
                if (a.target.getAttribute(a.attributeName) === a.oldValue)
                  continue;
                const t = n.scope.nodeIds.get(a.target);
                if (void 0 === t) continue;
                const s = b(
                    a.target,
                    n.scope.configuration.defaultPrivacyLevel,
                    e,
                  ),
                  r = Mt(a.target, s, a.attributeName, n.scope.configuration);
                let c;
                if ("value" === a.attributeName) {
                  const t = Et(a.target, s);
                  if (void 0 === t) continue;
                  c = t;
                } else c = "string" == typeof r ? r : null;
                let u = i.get(a.target);
                (u ||
                  ((u = { id: t, attributes: {} }),
                  o.push(u),
                  i.set(a.target, u)),
                  (u.attributes[a.attributeName] = c));
              }
              return o;
            })(
              s.filter((t) => "attributes" === t.type && !a(t.target)),
              n,
              e,
            );
          if (!(u.length || d.length || i.length || r.length)) return;
          e.add(Xt(ut, { adds: r, removes: i, texts: u, attributes: d }));
        })(t.concat(a.takeRecords()), e),
      );
    }),
    a = new r(A(i.addMutations));
  return (
    a.observe(t, {
      attributeOldValue: !0,
      attributes: !0,
      characterData: !0,
      characterDataOldValue: !0,
      childList: !0,
      subtree: !0,
    }),
    {
      stop: () => {
        (a.disconnect(), i.stop());
      },
      flush: () => {
        i.flush();
      },
    }
  );
}
function ue(t, e) {
  (E(t) && e(t.shadowRoot), h(t, (t) => ue(t, e)));
}
function de(t) {
  const { emitRecord: e, emitStats: n, configuration: o, lifeCycle: s } = t;
  if (!e || !n) throw new Error("emit functions are required");
  const r = (n) => {
      (e(n), P("record", { record: n }));
      const o = t.viewHistory.findView();
      z(o.id);
    },
    i = ((t, e) => {
      const n = new Map();
      return {
        addShadowRoot: (o, s) => {
          if (n.has(o)) return;
          const r = ce(o, t, e, s),
            i = ae(o, t, s),
            a = Zt(o, t, s);
          n.set(o, {
            flush: () => r.flush(),
            stop: () => {
              (r.stop(), i.stop(), a.stop());
            },
          });
        },
        removeShadowRoot: (t) => {
          const e = n.get(t);
          e && (e.stop(), n.delete(t));
        },
        stop: () => {
          n.forEach(({ stop: t }) => t());
        },
        flush: () => {
          n.forEach(({ flush: t }) => t());
        },
      };
    })(r, n),
    a = (function (t, e, n, o, s) {
      return {
        configuration: t,
        elementsScrollPositions: e,
        eventIds: n,
        nodeIds: o,
        shadowRootsController: s,
      };
    })(
      o,
      (function () {
        const t = new WeakMap();
        return {
          set(e, n) {
            (e !== document || document.scrollingElement) &&
              t.set(e === document ? document.scrollingElement : e, n);
          },
          get: (e) => t.get(e),
          has: (e) => t.has(e),
        };
      })(),
      (function () {
        const t = new WeakMap();
        let e = 1;
        return { getIdForEvent: (n) => (t.has(n) || t.set(n, e++), t.get(n)) };
      })(),
      (function () {
        const t = new WeakMap();
        let e = 0;
        const n = (e) => t.get(e);
        return {
          assign: (o) => {
            let s = n(o);
            return (void 0 === s && ((s = e++), t.set(o, s)), s);
          },
          get: n,
          areAssignedForNodeAndAncestors: (t) => {
            let e = t;
            for (; e; ) {
              if (void 0 === n(e) && !m(e)) return !1;
              e = x(e);
            }
            return !0;
          },
        };
      })(),
      i,
    ),
    { stop: c } = (function (t, e, n, o, s) {
      Ut(g(), 0, e, n, s);
      const { unsubscribe: r } = t.subscribe(2, (t) => {
        (o(), Ut(t.startClocks.timeStamp, 1, e, n, s));
      });
      return { stop: r };
    })(s, r, n, u, a);
  function u() {
    (i.flush(), d.flush());
  }
  const d = ce(document, r, n, a),
    l = [
      d,
      Wt(r, a),
      Kt(r, a),
      Zt(document, r, a),
      Qt(r, a),
      ae(document, r, a),
      ee(r, a),
      ne(r, a),
      se(r, a),
      te(r, a),
      re(s, r, a),
      ie(s, r, u),
    ];
  return {
    stop: () => {
      (i.stop(), l.forEach((t) => t.stop()), c());
    },
    flushMutations: u,
    shadowRootsController: i,
  };
}
function le({ context: t, creationReason: e, encoder: n }) {
  let o = 0;
  const s = t.view.id,
    r = {
      start: 1 / 0,
      end: -1 / 0,
      creation_reason: e,
      records_count: 0,
      has_full_snapshot: !1,
      index_in_view: V(s),
      source: "browser",
      ...t,
    },
    i = {
      cssText: { count: 0, max: 0, sum: 0 },
      serializationDuration: { count: 0, max: 0, sum: 0 },
    };
  return (
    H(s),
    {
      addRecord: function (t, e) {
        ((r.start = Math.min(r.start, t.timestamp)),
          (r.end = Math.max(r.end, t.timestamp)),
          (r.records_count += 1),
          r.has_full_snapshot || (r.has_full_snapshot = t.type === J));
        const s = n.isEmpty ? '{"records":[' : ",";
        n.write(s + JSON.stringify(t), (t) => {
          ((o += t), e(o));
        });
      },
      addStats: function (t) {
        !(function (t, e) {
          for (const n of ["cssText", "serializationDuration"])
            ((t[n].count += e[n].count),
              (t[n].max = Math.max(t[n].max, e[n].max)),
              (t[n].sum += e[n].sum));
        })(i, t);
      },
      flush: function (t) {
        if (n.isEmpty) throw new Error("Empty segment flushed");
        (n.write(`],${JSON.stringify(r).slice(1)}\n`),
          n.finish((e) => {
            (F(r.view.id, e.rawBytesCount), t(r, i, e));
          }));
      },
    }
  );
}
const fe = 5 * U;
let pe = 6e4;
function me(t, e, n, o, s, r) {
  return (function (t, e, n, o) {
    let s = { status: 0, nextSegmentCreationReason: "init" };
    const { unsubscribe: r } = t.subscribe(2, () => {
        a("view_change");
      }),
      { unsubscribe: i } = t.subscribe(11, (t) => {
        a(t.reason);
      });
    function a(t) {
      (1 === s.status &&
        (s.segment.flush((e, o, s) => {
          const r = (function (t, e, n, o) {
            const s = new FormData();
            s.append(
              "segment",
              new Blob([t], { type: "application/octet-stream" }),
              `${e.session.id}-${e.start}`,
            );
            const r = {
                raw_segment_size: o,
                compressed_segment_size: t.byteLength,
                ...e,
              },
              i = JSON.stringify(r);
            return (
              s.append("event", new Blob([i], { type: "application/json" })),
              {
                data: s,
                bytesCount: t.byteLength,
                cssText: n.cssText,
                isFullSnapshot: 0 === e.index_in_view,
                rawSize: o,
                recordCount: e.records_count,
                serializationDuration: n.serializationDuration,
              }
            );
          })(s.output, e, o, s.rawBytesCount);
          $(t) ? n.sendOnExit(r) : n.send(r);
        }),
        B(s.expirationTimeoutId)),
        (s =
          "stop" !== t
            ? { status: 0, nextSegmentCreationReason: t }
            : { status: 2 }));
    }
    return {
      addRecord: (t) => {
        if (2 !== s.status) {
          if (0 === s.status) {
            const t = e();
            if (!t) return;
            s = {
              status: 1,
              segment: le({
                encoder: o,
                context: t,
                creationReason: s.nextSegmentCreationReason,
              }),
              expirationTimeoutId: G(() => {
                a("segment_duration_limit");
              }, fe),
            };
          }
          s.segment.addRecord(t, (t) => {
            t > pe && a("segment_bytes_limit");
          });
        }
      },
      addStats: (t) => {
        1 === s.status && s.segment.addStats(t);
      },
      stop: () => {
        (a("stop"), r(), i());
      },
    };
  })(
    t,
    () =>
      (function (t, e, n) {
        const o = e.findTrackedSession(),
          s = n.findView();
        if (!o || !s) return;
        return {
          application: { id: t },
          session: { id: o.id },
          view: { id: s.id },
        };
      })(e.applicationId, n, o),
    s,
    r,
  );
}
function he(t, e, n, o, s, r, i) {
  const a = [],
    c =
      i ||
      X(
        [e.sessionReplayEndpointBuilder],
        (e) => {
          (t.notify(14, { error: e }),
            q("Error reported to customer", { "error.message": e.message }));
        },
        pe,
      );
  let u, d;
  if (W())
    (({ addRecord: u } = (function (t) {
      const e = j();
      return {
        addRecord: (n) => {
          const o = t.findView();
          e.send("record", n, o.id);
        },
      };
    })(o)),
      (d = R));
  else {
    const i = me(t, e, n, o, c, s);
    ((u = i.addRecord), (d = i.addStats), a.push(i.stop));
    const l = (function (t, e) {
      if (!t.metricsEnabled) return { stop: R };
      const { unsubscribe: n } = e.subscribe((t) => {
        if (
          "failure" === t.type ||
          "queue-full" === t.type ||
          ("success" === t.type && t.payload.isFullSnapshot)
        ) {
          const s =
            ((e = t.type),
            (n = t.bandwidth),
            {
              cssText: {
                count: (o = t.payload).cssText.count,
                max: o.cssText.max,
                sum: o.cssText.sum,
              },
              isFullSnapshot: o.isFullSnapshot,
              ongoingRequests: {
                count: n.ongoingRequestCount,
                totalSize: n.ongoingByteCount,
              },
              recordCount: o.recordCount,
              result: e,
              serializationDuration: {
                count: o.serializationDuration.count,
                max: o.serializationDuration.max,
                sum: o.serializationDuration.sum,
              },
              size: { compressed: o.bytesCount, raw: o.rawSize },
            });
          Y("Segment network request metrics", { metrics: s });
        }
        var e, n, o;
      });
      return { stop: n };
    })(r, c.observable);
    a.push(l.stop);
  }
  const { stop: l } = de({
    emitRecord: u,
    emitStats: d,
    configuration: e,
    lifeCycle: t,
    viewHistory: o,
  });
  return (
    a.push(l),
    {
      stop: () => {
        a.forEach((t) => t());
      },
    }
  );
}
export { he as startRecording };
